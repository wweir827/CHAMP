.. CHAMP documentation master file, created by
   sphinx-quickstart on Tue Jul 11 15:50:43 2017.
   You can adapt this file completely to your liking, but it should at least
   contain the root `toctree` directive.

=================================
Louvain Parallel Extension
=================================

CHAMP can be used with partitions generated by any community detection algorithm.  One of the most popular \
and fast algorithms is known as Louvain :cite:`Blondel:2008vn` .  We provide an extension to the python package \
developed by Vincent Traag, `louvain_igraph <https://github.com/vtraag/louvain-igraph>`_  :cite:`traag_louvain` to \
run Louvain in parallel, while calculating the coefficients necessary for CHAMP.  Currently, this extension only \
support single-layer network.  The random seed is set within each parallel process to ensure that the results are
stochastic over each run.  In general this is desireable because Louvain uses a greedy optimization schema that \
finds *local* optima.



.. autofunction:: champ.louvain_ext.parallel_louvain


We also have created a convenient class for managing and merging groups of partitions \
called :mod:`champ.louvain_ext.PartitionEnsemble` .  This class stores the partitions in membership vector form \
( i.e. a list of N community assignments), as well as the coefficients for the partitions.  As part of its \
constructor, the PartitionEnsemble applies CHAMP to all of its partitions, and stores the domains of dominance.


.. _`louvain_ext.PartitionEnsemble`:
.. autoclass:: champ.louvain_ext.PartitionEnsemble
    :members:

----------------------------
Partition Ensemble Example
----------------------------
We use igraph to generate a random ER graph, call louvain in parallel, and apply CHAMP to the ensemble.
::

    import champ
    import igraph as ig
    import tempfile
    import numpy as np
    import matplotlib.pyplot as plt

    np.random.seed(0)
    test_graph=ig.Graph.Erdos_Renyi(500,p=.05)
    #Create temporary file for calling louvain
    tfile=tempfile.NamedTemporaryFile('wb')
    test_graph.write_graphmlz(tfile.name)

    #non-parallelized wrapper
    ens1=champ.run_louvain(tfile.name,nruns=2,gamma=1)

    #parallelized wrapper
    test_graph2=ig.Graph.Random_Bipartite(n1=100,n2=100,p=.1)
    ens2=champ.parallel_louvain(test_graph2,
                                      numruns=1000,start=0,fin=4,maxpt=4,
                                      numprocesses=2,
                                      progress=True)

    print ("%d of %d domains after application of CHAMP"%(len(ens2.ind2doms),ens2.numparts))

    #plot both of these
    plt.close()
    f,(a1,a2)=plt.subplots(1,2,figsize=(10,5))
    champ.plot_single_layer_modularity_domains(ens2.ind2doms,ax=a1,labels=True)
    champ.plot_similarity_heatmap_single_layer(ens2.partitions,ens2.ind2doms,ax=a2,title=True)
    plt.tight_layout()
    plt.show()



Output\:

|   Run 0 at gamma = 0.000.  Return time: 0.0326
|   Run 100 at gamma = 0.400.  Return time: 0.0318
|   Run 200 at gamma = 0.800.  Return time: 0.0665
|   Run 300 at gamma = 1.200.  Return time: 0.0659
|   Run 400 at gamma = 1.600.  Return time: 0.0936
|   Run 500 at gamma = 2.000.  Return time: 0.0715
|   Run 600 at gamma = 2.400.  Return time: 0.0811
|   Run 700 at gamma = 2.800.  Return time: 0.0780
|   Run 800 at gamma = 3.200.  Return time: 0.0759
|   Run 900 at gamma = 3.600.  Return time: 0.0735
|   12 of 1000 domains after application of CHAMP

.. _`part_ens_exp`:
.. image::  images/part_ens_exp.png
   :width: 90%


References
___________

.. bibliography:: biblio.bib
    :style: plain
    :filter: docname in docnames




* :ref:`genindex`
* :ref:`search`

